from PyQt5.QtCore import Qt, QRectF, QLineF, QPointF, QSizeF, \
                        qFuzzyCompare, QTimeLine
from PyQt5.QtGui import QColor, QPen, QPolygonF, QPainterPath, QBrush
import math
from .base_edge import BaseEdge
from ....core.graph.constants import EdgeStatus


class ExplorerEdge(BaseEdge):
    def __init__(self, source_node, destination_node, metadata, nx_pos, steps, steps_max):
        """
        Create an arc between two nodes

        :param Node source_node: Source node of the arc
        :param Node destination_node: Destination node of the arc
        :param dict metadata: Arc metadata
        :param dict nx_pos: The position generated by nx_graph
        :param int steps: The steps from the center identity
        :param int steps_max: The steps max of the graph
        """
        super().__init__(source_node, destination_node, metadata, nx_pos)

        self.source_point = self.destination_point
        self.steps = steps
        self.steps_max = steps_max
        self.highlighted = False

        self.arrow_size = 5
        #  cursor change on hover
        self.setAcceptHoverEvents(True)
        self.setZValue(0)
        self._line_styles = {
            EdgeStatus.STRONG: Qt.SolidLine,
            EdgeStatus.WEAK: Qt.DashLine
        }
        self.timeline = None
        self.setToolTip(self.metadata['tooltip'])

    @property
    def line_style(self):
        return self._line_styles[self.status]

    # virtual function require subclassing
    def boundingRect(self):
        """
        Return the bounding rectangle size

        :return: QRectF
        """
        if not self.source or not self.destination:
            return QRectF()
        pen_width = 1.0
        extra = (pen_width + self.arrow_size) / 2.0

        return QRectF(
            self.source_point, QSizeF(
                self.destination_point.x() - self.source_point.x(),
                self.destination_point.y() - self.source_point.y()
            )
        ).normalized().adjusted(
            -extra,
            -extra,
            extra,
            extra
        )

    def paint(self, painter, option, widget):
        """
        Customize line adding an arrow head

        :param QPainter painter: Painter instance of the item
        :param option:  Painter option of the item
        :param widget:  Widget instance
        """
        if not self.source or not self.destination:
            return
        line = QLineF(self.source_point, self.destination_point)
        if qFuzzyCompare(line.length(), 0):
            return

        # Draw the line itself
        color = QColor()
        color.setHsv(120 - 60 / self.steps_max * self.steps,
                     180 + 50 / self.steps_max * self.steps,
                     150 + 80 / self.steps_max * self.steps)
        if self.highlighted:
            color.setHsv(0, 0, 0)

        style = self.line_style

        painter.setPen(QPen(color, 1, style, Qt.RoundCap, Qt.RoundJoin))
        painter.drawLine(line)
        painter.setPen(QPen(color, 1, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))

        # Draw the arrows
        angle = math.acos(line.dx() / line.length())
        if line.dy() >= 0:
            angle = (2.0 * math.pi) - angle

        #  arrow in the middle of the arc
        hpx = line.p1().x() + (line.dx() / 2.0)
        hpy = line.p1().y() + (line.dy() / 2.0)
        head_point = QPointF(hpx, hpy)

        # debug : display shape for tooltip triggering zone
        #painter.fillPath(self.shape(), QBrush(QColor(0, 255, 0, 255)))

        painter.setPen(QPen(color, 1, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
        destination_arrow_p1 = head_point + QPointF(
            math.sin(angle - math.pi / 3) * self.arrow_size,
            math.cos(angle - math.pi / 3) * self.arrow_size)
        destination_arrow_p2 = head_point + QPointF(
            math.sin(angle - math.pi + math.pi / 3) * self.arrow_size,
            math.cos(angle - math.pi + math.pi / 3) * self.arrow_size)

        painter.setBrush(color)
        painter.drawPolygon(QPolygonF([head_point, destination_arrow_p1, destination_arrow_p2]))

        if self.metadata["confirmation_text"]:
            painter.drawText(head_point, self.metadata["confirmation_text"])

    def move_source_point(self, node_id, x, y):
        """
        Move to corresponding position
        :param str node_id: the node id
        :param float x: x coordinates
        :param float y: y coordinates
        :return:
        """
        if node_id == self.source:
            self.source_point = QPointF(x, y)
            self.update(self.boundingRect())

    def move_destination_point(self, node_id, x, y):
        """
        Move to corresponding position
        :param str node_id: the node id
        :param float x: x coordinates
        :param float y: y coordinates
        :return:
        """
        if node_id == self.destination:
            self.destination_point = QPointF(x, y)
            self.update(self.boundingRect())

    def highlight(self):
        """
        Highlight the edge in the scene
        """
        self.highlighted = True
        self.update(self.boundingRect())

    def neutralize(self):
        """
        Neutralize the edge in the scene
        """
        self.highlighted = False
        self.update(self.boundingRect())

    def shape(self):
        """
        Return real shape of the item to detect collision or hover accurately

        :return: QPainterPath
        """
        if not self.source or not self.destination:
            return
        line = QLineF(self.source_point, self.destination_point)

        # detection mouse hover on arc path
        path = QPainterPath()
        path.addPolygon(QPolygonF([line.p1(), line.p2()]))

        #  arrow in the middle of the arc
        hpx = line.p1().x() + (line.dx() / 2.0)
        hpy = line.p1().y() + (line.dy() / 2.0)

        # add detection zone around the arrow head
        path.addRect(QRectF(
            hpx-10,
            hpy-10,
            20,
            20
        ))

        return path
